1: use the system builder provided by terasic
2: to make the led test program we need to enable the CLK, LEDS and HPS then we can generate the qpf file
3: open the generated qpf file with Quartus
4: you can remove the other clocks, we only need "input CLOCK_50," and we can edit our leds from [9:0]  10 leds to [7:0] 8 leds
5: we can remove the SPI interface if we don't need it by deleting:
	*output		          		HPS_SPIM_CLK,
	*input 		          		HPS_SPIM_MISO,
	*output		          		HPS_SPIM_MOSI,
	*output		          		HPS_SPIM_SS,

6: we also don't need the external reset, the LTC_GPIO, HPS_LED, LCM (LCD), I2C or GSENSOR.
	*inout 		          		HPS_GSENSOR_INT,
	*inout 		          		HPS_I2C1_SCLK,
	*inout 		          		HPS_I2C1_SDAT,
	*inout 		          		HPS_I2C2_SCLK,
	*inout 		          		HPS_I2C2_SDAT,
	*inout 		          		HPS_I2C_CONTROL,
	*inout 		          		HPS_KEY,
	*inout 		          		HPS_LCM_BK,
	*inout 		          		HPS_LCM_D_C,
	*inout 		          		HPS_LCM_RST_N,
	*output		          		HPS_LCM_SPIM_CLK,
	*input 		          		HPS_LCM_SPIM_MISO,
	*output		          		HPS_LCM_SPIM_MOSI,
	*output		          		HPS_LCM_SPIM_SS,
	*inout 		          		HPS_LED,
	*inout 		          		HPS_LTC_GPIO,

7: we don't need the flash interface, since we already have the sd one:
	*inout 		     [3:0]		HPS_FLASH_DATA,
	*output		          		HPS_FLASH_DCLK,
	*output		          		HPS_FLASH_NCSO,

8: USB-UART pin is reserved so you can remove or leave this line:
	*inout 		          		HPS_CONV_USB_N,

9: open up the Platform designer aka (Qsys) from tools in Quartus.
10: create a new Qsys file and let's name it for example "hps"
11: From the IP catalog add the Arria V/Cyclone V HPS found under Hard Processor Systems under Processors and Peripherals
12: configure the HPS with the following configuration (copied from the GHRD reference file by terasic)
	
	In the FPGA Interfaces tab:

		* Disable MPU standby and signal events
		* Disable the FPGA-to-HPS interface width
		* Disable the HPS-to-FPGA interface width
		* Lightweight HPS-to-FPGA (32 bit)
		* remove the SDRAM, since we already have the DDR3RAM.
	
	In the Peripheral Interfaces tab:

		*EMAC1 pin: HPS I/O Set 0
		*EMAC1 mode: RGMII

		*NAND Flash controller was already removed 
		
		*Quad SPI Flash controller was already removed

		* SDIO pin: HPS I/O set 0
		* SDIO mode: 4-bit data parallel

		* USB1 pin: HPS I/O set 0
		* USB1 PHY interface mode: SDR with PHY clock output mode

		* SPI was already removed

		* UART0 pin: HPS I/O set 0
		* UART0 mode: No Flow control

		* I2C was already removed

		* We don't need the CAN bus interface or the Trace Port interface
		
		*configure the 1 open-drain output from the reset chip to the ethernet controller by exporting GPIO pin 35 (go click on it in the MUX Table)

	In the HPS clock, Input Clocks tab:
		
		* External clock sources should be 25.0 MHz

	In the HPS clock, Output Clocks tab:
		
		* PLL clock source: EOSC1 clock
		* SDMMC clock source: Peripheral NAND SDMMC clock
		* L4MP clock source: Peripheral base clock
		* LM4SP clock source: Peripheral base clock
		* L3MP clock frequency: 185.0 MHz
		* L3SP clock frequency: 92.5 MHz
		* Debug AT clock frequency: 25.0 MHz
		* Debug CLK frequency: 12.5 MHz
		* Debug trace clock frequency: 25 MHz
		* L4MP clock frequency: 100 MHz
		* L4SP clock freqency: 100 MHz
		* HPS-to-FPGA user 0 clock freqency: 100 MHz
		* SDMMC CLK freq: 200 MHz
		* USB CLK freq: 200 MHz
		* GPIO debounce CLK freq: 32k Hz
		* HPS-to-FPGA user 0 CLK freq: 100 MHz
	
	In the SDRAM, PHY settings tab:
		
		* Memory CLK frequency: 400 MHz
		* PLL reference CLK frequency: 25 MHz

	In the SDRAM, Memory Parameters tab:
		
		* Memory vendor: Micron
		* Total interface width: 32-bit (x2 16-bit devices)
		* Number of DQS groups: 4
		* Row address width: 15
		* Column address width: 10
		* Bank-address width: 3
		* Memory CAS latency settings: 11
		* ODT Rtt nominal value: RZQ/6
		* Memory write CAS latency setting: 7
	
	In the SDRAM, Memory timing tab:
		
		* tIS (base): 190 ps
		* tIH (base): 140 ps
		* tDS (base): 30 ps
		* tDH (base): 65 ps
		* tDQSQ: 125 ps
		* tQH: 0.38 cycles
		* tDQSCK: 255 ps
		* tDQSS: 0.25 cycles
		* tQSH: 0.4 cycles
		* tDSH: 0.2 cycles
		* tDSS: 0.2 cycles
		* tINT: 500 us
		* tMRD: 4 cycles
		* tRAS: 35 ns
		* tRCD: 13.75 ns
		* tRP: 13.75 ns
		* tREFI: 7.8 ns
		* tRFC: 260.0 ns
		* tWR: 15 ns
		* tWTR: 4 cycles
		* tFAW: 45.0 ns
		* tRRD: 7.5 ns
		* tRTP 7.5 ns
	
	In the SDRAM, Board settings tab:
		
		* Maximum CK delay to DIMM/device: 0.03 ns
		* Maximum DQS delay to DIMM/device: 0.02 ns
		* Minimum delay difference between CK and DQS: 0.06 ns
		* Maximum delay difference between CK and DQS: 0.12 ns
		* Maximum skew within the DQS group: 0.01 ns
		* Maximum sekw between the DQS groups: 0.06 ns
		* Average delay difference between DQ and DQS: 0.05 ns
		* Maximum skew within address and command bus: 0.02 ns
		* Average delay difference between address and command and CK: 0.01 ns
		
13: Finish
14: we want the HPS to be the master reset output (it resets the main bus clk and the bus clk resets all) so we click on "h2f_reset" and we connect it to "clk_in_reset" by clickign on the small circle in the System Contents view
15: also the clock output will be the clock input for the Avalon interconnect (AXI bus) by connecting the "clk" to the "h2f_lw_axi_clock"
16: now we can add peripherals such as a PIO (register) with Direction output to power up the 8 leds

	Note: a c code line such as  *led<<=1;  would require the direction to be in/out not output
	So you should use something like *led = 1<<i;

17: connect the CLK reset to the reset of the ledReg
18: connect the CLK to the peripheral
19: connect the Slave port "s1" to the master port of the main processor "h2f_lw_axi_master"

	Note: the AXI bus and the Avalon memory mapped bus are connected through the pipelined Avalon interconnect bridge
	we can add it or we can compile and Qsys will add the bridge converters needed and handle the rest.

20: export the external_connection by double clicking on export
21: Generate the HDL files

	Note: notice that the avalon_st_adapter: "mn_interconnect_0" has been added

22: we want to add the generated HDL block into our top level design. Generate -> show instantiation template and copy it
23: paste it under "structural coding" in Quartus in your top level Verilog design created when we first started the project
24: now add the Qsys file from project -> Add/remove files
25: now start connecting your modules with their respective wires and connections

26: It should look like this
	    hps u0 (
        .clk_clk                           (CLOCK_50),                        						//                        clk.clk
        .memory_mem_a                      (HPS_DDR3_ADDR),                   						//                     memory.mem_a
        .memory_mem_ba                     (HPS_DDR3_BA),                     						//                           .mem_ba
        .memory_mem_ck                     (HPS_DDR3_CK_P),                   						//                           .mem_ck
        .memory_mem_ck_n                   (HPS_DDR3_CK_N),                   						//                           .mem_ck_n
        .memory_mem_cke                    (HPS_DDR3_CKE),                    						//                           .mem_cke
        .memory_mem_cs_n                   (HPS_DDR3_CS_N),                   						//                           .mem_cs_n
        .memory_mem_ras_n                  (HPS_DDR3_RAS_N),                  						//                           .mem_ras_n
        .memory_mem_cas_n                  (HPS_DDR3_CAS_N),                  						//                           .mem_cas_n
        .memory_mem_we_n                   (HPS_DDR3_WE_N),                   						//                           .mem_we_n
        .memory_mem_reset_n                (HPS_DDR3_RESET_N),                						//                           .mem_reset_n
        .memory_mem_dq                     (HPS_DDR3_DQ),                     						//                           .mem_dq
        .memory_mem_dqs                    (HPS_DDR3_DQS_P),                  						//                           .mem_dqs
        .memory_mem_dqs_n                  (HPS_DDR3_DQS_N),                  						//                           .mem_dqs_n
        .memory_mem_odt                    (HPS_DDR3_ODT),                    						//                           .mem_odt
        .memory_mem_dm                     (HPS_DDR3_DM),                     						//                           .mem_dm
        .memory_oct_rzqin                  (HPS_DDR3_RZQ),                    						//                           .oct_rzqin
        .hps_io_hps_io_emac1_inst_TX_CLK   (HPS_ENET_GTX_CLK),   											//                     hps_io.hps_io_emac1_inst_TX_CLK
        .hps_io_hps_io_emac1_inst_TXD0     (HPS_ENET_TX_DATA[0]),     									//                           .hps_io_emac1_inst_TXD0
        .hps_io_hps_io_emac1_inst_TXD1     (HPS_ENET_TX_DATA[1]),     									//                           .hps_io_emac1_inst_TXD1
        .hps_io_hps_io_emac1_inst_TXD2     (HPS_ENET_TX_DATA[2]),    		 							//                           .hps_io_emac1_inst_TXD2
        .hps_io_hps_io_emac1_inst_TXD3     (HPS_ENET_TX_DATA[3]),     									//                           .hps_io_emac1_inst_TXD3
        .hps_io_hps_io_emac1_inst_RXD0     (HPS_ENET_RX_DATA[0]),     									//                           .hps_io_emac1_inst_RXD0
        .hps_io_hps_io_emac1_inst_MDIO     (HPS_ENET_MDIO),     											//                           .hps_io_emac1_inst_MDIO
        .hps_io_hps_io_emac1_inst_MDC      (HPS_ENET_MDC),      											//                           .hps_io_emac1_inst_MDC
        .hps_io_hps_io_emac1_inst_RX_CTL   (HPS_ENET_RX_DV),   											//                           .hps_io_emac1_inst_RX_CTL
        .hps_io_hps_io_emac1_inst_TX_CTL   (HPS_ENET_TX_EN),   											//                           .hps_io_emac1_inst_TX_CTL
        .hps_io_hps_io_emac1_inst_RX_CLK   (HPS_ENET_RX_CLK),   											//                           .hps_io_emac1_inst_RX_CLK
        .hps_io_hps_io_emac1_inst_RXD1     (HPS_ENET_RX_DATA[1]),     									//                           .hps_io_emac1_inst_RXD1
        .hps_io_hps_io_emac1_inst_RXD2     (HPS_ENET_RX_DATA[2]),    									//                           .hps_io_emac1_inst_RXD2
        .hps_io_hps_io_emac1_inst_RXD3     (HPS_ENET_RX_DATA[3]),     									//                           .hps_io_emac1_inst_RXD3
        .hps_io_hps_io_sdio_inst_CMD       (HPS_SD_CMD),       											//                           .hps_io_sdio_inst_CMD
        .hps_io_hps_io_sdio_inst_D0        (HPS_SD_DATA[0]),        										//                           .hps_io_sdio_inst_D0
        .hps_io_hps_io_sdio_inst_D1        (HPS_SD_DATA[1]),        										//                           .hps_io_sdio_inst_D1
        .hps_io_hps_io_sdio_inst_CLK       (HPS_SD_CLK),       											//                           .hps_io_sdio_inst_CLK
        .hps_io_hps_io_sdio_inst_D2        (HPS_SD_DATA[2]),        										//                           .hps_io_sdio_inst_D2
        .hps_io_hps_io_sdio_inst_D3        (HPS_SD_DATA[3]),        										//                           .hps_io_sdio_inst_D3
        .hps_io_hps_io_usb1_inst_D0        (HPS_USB_DATA[0]),        									//                           .hps_io_usb1_inst_D0
        .hps_io_hps_io_usb1_inst_D1        (HPS_USB_DATA[1]),        									//                           .hps_io_usb1_inst_D1
        .hps_io_hps_io_usb1_inst_D2        (HPS_USB_DATA[2]),        									//                           .hps_io_usb1_inst_D2
        .hps_io_hps_io_usb1_inst_D3        (HPS_USB_DATA[3]),        									//                           .hps_io_usb1_inst_D3
        .hps_io_hps_io_usb1_inst_D4        (HPS_USB_DATA[4]),        									//                           .hps_io_usb1_inst_D4
        .hps_io_hps_io_usb1_inst_D5        (HPS_USB_DATA[5]),        									//                           .hps_io_usb1_inst_D5
        .hps_io_hps_io_usb1_inst_D6        (HPS_USB_DATA[6]),        									//                           .hps_io_usb1_inst_D6
        .hps_io_hps_io_usb1_inst_D7        (HPS_USB_DATA[7]),        									//                           .hps_io_usb1_inst_D7
        .hps_io_hps_io_usb1_inst_CLK       (HPS_USB_CLKOUT),       										//                           .hps_io_usb1_inst_CLK
        .hps_io_hps_io_usb1_inst_STP       (HPS_USB_STP),       											//                           .hps_io_usb1_inst_STP
        .hps_io_hps_io_usb1_inst_DIR       (HPS_USB_DIR),       											//                           .hps_io_usb1_inst_DIR
        .hps_io_hps_io_usb1_inst_NXT       (HPS_USB_NXT),       											//                           .hps_io_usb1_inst_NXT
        .hps_io_hps_io_uart0_inst_RX       (HPS_UART_RX),       											//                           .hps_io_uart0_inst_RX
        .hps_io_hps_io_uart0_inst_TX       (HPS_UART_TX),      											//                           .hps_io_uart0_inst_TX
        .hps_io_hps_io_gpio_inst_GPIO35    (<connected-to-hps_io_hps_io_gpio_inst_GPIO35>),   	//                           .hps_io_gpio_inst_GPIO35
        .ledreg_external_connection_export (LEDR) 	 															// ledreg_external_connection.export
    );

27: don't forget to replace "<connected-to-hps_io_hps_io_gpio_inst_GPIO35>" with HPS_ENET_INT_N
      
      *then from quartus, Project -> Add/Remove files to project -> add the qsys file -> press OK

28: save and then Start Analysis & Elaboration (letting Quartus know about our hps module and pin setups)

	NOTICE how Quartus insets the interconnect that we left out:
		
		*Info (12250): Interconnect is inserted between master hps_0.h2f_lw_axi_master and slave ledReg.s1 because the master is of type axi and the slave is of type avalon.
29: Qsys also generates .Tcl files that help us to do the pin constraints found in tools -> tcl scripts -> hps -> submodules -> parameters.tcl (run) and pin_assignment (run)
30: Compile and Synthesize the design. (Should take around 3~5 mins)
31: your design won't fit in device, so you should go back and do step 29 again.

32: before compiling your design again go to assignments -> device

~~~~IMPORTANT~~~~

33: don't accept Quartu's recommendation and press NO, and make sure to pick the right SoC FPGA device again because Quartus change it back to default.

Show available devices: Any, Any, Any.

Device Family: Cyclone V
Device: Cyclone V SX Extended Features

NAME: 5CSXFC6D6F31C6

~~~~IMPORTANT~~~~

34: device and pin options:
	* Unused pins -> Reserve all unsued pins: As input tri-stated 

	NOTE: (The weak pull up will make the leds toggeled but on dim brightness (DEFAULT))

35: if you check your pin planner you should find the CLK and the LedReg planned
	
	NOTE: You can delete the unused signals (Unknown) or just ignore them

36: Synthesize again

37: add intelFPGA_lite bin folder to your PATH environment variable "C:\intelFPGA_lite\18.1\quartus\sopc_builder\bin" or whatever path you have
38: open your SoC EDS command shell enviroment and cd into your working project directory: cd Desktop/SoC\ FPGA\ project\ 1\ Files/SoC\ FPGA/Qsys_led_test_system_builder/
	
	NOTE: if you have spaces you write your path like my example
39: edit the generate_hps_qsys_header.sh with notepad and change "./soc_system.sopcinfo" \ to "./yourSopcFileName.sopcinfo" \ 

40: ./generate_hps_qsys_header.sh

41: if it worked you should see: swinfo2header: Creating macro file 'hps_0.h' for module 'hps_0' and you should be able to find the .h file in the project directory

42: Now it's time to go work on the HPS code

	* make your program.c file
	* make a makefile
	* copy your hps_0.h file to your c code directory
	* create an rbf by copying the sof_to_rbf.bat script or by creating one
	%QUARTUS_ROOTDIR%\\bin64\\quartus_cpf -c YourProjectName.sof -o bitstream_compression=on soc_system.rbf
pause
	* copy the .sof file into your c code directory and run the .bat script
	* Your .rbf file should be read and generated
	* Compile your program using the make file by writing "make" in the c code directory from the EDS shell	

43: We need to generate a .dtb file by copying our hps.sopcinfo file into our HPS files and code

44: run the following  commands from the eds:

	sopc2dts.exe -g --input nameOfQsysFile.sopcinfo --output nameOfFPGAconfig.dts --type dts  --bridge-removal all --clocks
	
	1: sopc2dts.exe -g --input hps.sopcinfo --output fpga.dts --type dts  --bridge-removal all --clocks

	2: dtc -O dtb -o fpga.dtbo -b 0 -@ fpga.dts


43: connect your board via USB and connect your DE-10 to your router using ethernet, open putty and make sure that your sd card has your console linux on it.

44: Now we have both the rbf file and dtbo file, so let's transfer them to the DE-10

FPGA programming guide track 1 (doesn't work properly):

	* on the DE-10 console type "udhcpc" to connect to the network
	* on your EDS console type: scp fileName root@ip:~
	* LOAD both the .rbf and .dtbo files and also load your compiled program
	
	it should look like this:
	
	Barbary@LAPTOP-95R9DUMQ ~/Desktop/SoC FPGA project 1 Files/SoC FPGA/Qsys_led_test_system_builder/HPS files and code
	$ scp fpga.rbf root@192.168.1.9:/lib/firmware/
	Could not create directory '/home/Barbary/.ssh'.
	The authenticity of host '192.168.1.9 (192.168.1.9)' can't be established.
	ECDSA key fingerprint is SHA256:BpRAyPeHSLUGBb9R2+SWpUU9emINgm8o1iStfZx8mdc.
	Are you sure you want to continue connecting (yes/no)? yes
	Failed to add the host to the list of known hosts (/home/Barbary/.ssh/known_hosts).
	fpga.rbf                                                                              100% 1913KB   6.2MB/s   00:00

	Barbary@LAPTOP-95R9DUMQ ~/Desktop/SoC FPGA project 1 Files/SoC FPGA/Qsys_led_test_system_builder/HPS files and code
	$ scp fpga.dtbo root@192.168.1.9:/lib/firmware/
	Could not create directory '/home/Barbary/.ssh'.
	The authenticity of host '192.168.1.9 (192.168.1.9)' can't be established.
	ECDSA key fingerprint is SHA256:BpRAyPeHSLUGBb9R2+SWpUU9emINgm8o1iStfZx8mdc.
	Are you sure you want to continue connecting (yes/no)? yes
	Failed to add the host to the list of known hosts (/home/Barbary/.ssh/known_hosts).
	fpga.dtbo                                                                             100%   23KB 500.8KB/s   00:00

	Your DE-10 console should look like this after the 3 transfers:

	root@socfpga:~/SoC_FPGA_test# ls
	main

	root@socfpga:~/SoC_FPGA_test# ls /lib/firmware
	fpga.dtbo  fpga.rbf  mt7601u.bin


	if you don't have a configfs then create one
	* make a config file system directory: mount -t configfs configfs /config
	* go to config using: cd /config/
	* go to the overlays folder created in the config directory (automatically) using :cd /config/device-tree/overlays/
	* make an FPGA configuration directory (name doesn't matter as long as you can reach it): mkdir fpga_reconfiguration

	* load the fpga.dtbo to the path folder created in our FPGA configuration directory "fpga_reconfiguration" using echo fpga.dtbo > fpga_reconfiguration/path

FPGA programming track 2:

	* Connect the DE-10 to your computer and use the Quartus programmer "You can refer to the datasheet for more info"

FPGA programming track 3:

	I made this script to load the soc_system.rbf with the uboot

	reconfigureFPGA.sh: 
		
	mkdir -p fat
	mount /dev/mmcblk0p1 fat
	cp soc_system.rbf fat/soc_system.rbf
	umount fat
	reboot

	*before running the reconfigureFPGA.sh file remember to make it executable or you will get permission denied.
	chmod u+r+x reconfigureFPGA.sh	

SoC programming guide:

	* after transfering the executable file to the DE-10 use ./file to run it and ctrl+c to stop it
	

	

	